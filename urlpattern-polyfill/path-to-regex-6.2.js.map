{"version":3,"file":"path-to-regex-6.2.js","sourceRoot":"","sources":["../src/path-to-regex-6.2.ts"],"names":[],"mappings":"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","sourcesContent":["/**\r\n * Tokenizer results.\r\n */\r\ninterface LexToken {\r\n    type:\r\n      | \"OPEN\"\r\n      | \"CLOSE\"\r\n      | \"PATTERN\"\r\n      | \"NAME\"\r\n      | \"CHAR\"\r\n      | \"ESCAPED_CHAR\"\r\n      | \"MODIFIER\"\r\n      | \"END\";\r\n    index: number;\r\n    value: string;\r\n  }\r\n  \r\n  /**\r\n   * Tokenize input string.\r\n   */\r\n  function lexer(str: string): LexToken[] {\r\n    const tokens: LexToken[] = [];\r\n    let i = 0;\r\n  \r\n    while (i < str.length) {\r\n      const char = str[i];\r\n  \r\n      if (char === \"*\" || char === \"+\" || char === \"?\") {\r\n        tokens.push({ type: \"MODIFIER\", index: i, value: str[i++] });\r\n        continue;\r\n      }\r\n  \r\n      if (char === \"\\\\\") {\r\n        tokens.push({ type: \"ESCAPED_CHAR\", index: i++, value: str[i++] });\r\n        continue;\r\n      }\r\n  \r\n      if (char === \"{\") {\r\n        tokens.push({ type: \"OPEN\", index: i, value: str[i++] });\r\n        continue;\r\n      }\r\n  \r\n      if (char === \"}\") {\r\n        tokens.push({ type: \"CLOSE\", index: i, value: str[i++] });\r\n        continue;\r\n      }\r\n  \r\n      if (char === \":\") {\r\n        let name = \"\";\r\n        let j = i + 1;\r\n  \r\n        while (j < str.length) {\r\n          const code = str.charCodeAt(j);\r\n  \r\n          if (\r\n            // `0-9`\r\n            (code >= 48 && code <= 57) ||\r\n            // `A-Z`\r\n            (code >= 65 && code <= 90) ||\r\n            // `a-z`\r\n            (code >= 97 && code <= 122) ||\r\n            // `_`\r\n            code === 95\r\n          ) {\r\n            name += str[j++];\r\n            continue;\r\n          }\r\n  \r\n          break;\r\n        }\r\n  \r\n        if (!name) throw new TypeError(`Missing parameter name at ${i}`);\r\n  \r\n        tokens.push({ type: \"NAME\", index: i, value: name });\r\n        i = j;\r\n        continue;\r\n      }\r\n  \r\n      if (char === \"(\") {\r\n        let count = 1;\r\n        let pattern = \"\";\r\n        let j = i + 1;\r\n  \r\n        if (str[j] === \"?\") {\r\n          throw new TypeError(`Pattern cannot start with \"?\" at ${j}`);\r\n        }\r\n  \r\n        while (j < str.length) {\r\n          if (str[j] === \"\\\\\") {\r\n            pattern += str[j++] + str[j++];\r\n            continue;\r\n          }\r\n  \r\n          if (str[j] === \")\") {\r\n            count--;\r\n            if (count === 0) {\r\n              j++;\r\n              break;\r\n            }\r\n          } else if (str[j] === \"(\") {\r\n            count++;\r\n            if (str[j + 1] !== \"?\") {\r\n              throw new TypeError(`Capturing groups are not allowed at ${j}`);\r\n            }\r\n          }\r\n  \r\n          pattern += str[j++];\r\n        }\r\n  \r\n        if (count) throw new TypeError(`Unbalanced pattern at ${i}`);\r\n        if (!pattern) throw new TypeError(`Missing pattern at ${i}`);\r\n  \r\n        tokens.push({ type: \"PATTERN\", index: i, value: pattern });\r\n        i = j;\r\n        continue;\r\n      }\r\n  \r\n      tokens.push({ type: \"CHAR\", index: i, value: str[i++] });\r\n    }\r\n  \r\n    tokens.push({ type: \"END\", index: i, value: \"\" });\r\n  \r\n    return tokens;\r\n  }\r\n  \r\n  export interface ParseOptions {\r\n    /**\r\n     * Set the default delimiter for repeat parameters. (default: `'/'`)\r\n     */\r\n    delimiter?: string;\r\n    /**\r\n     * List of characters to automatically consider prefixes when parsing.\r\n     */\r\n    prefixes?: string;\r\n  }\r\n  \r\n  /**\r\n   * Parse a string for the raw tokens.\r\n   */\r\n  export function parse(str: string, options: ParseOptions = {}): Token[] {\r\n    const tokens = lexer(str);\r\n    const { prefixes = \"./\" } = options;\r\n    const defaultPattern = `[^${escapeString(options.delimiter || \"/#?\")}]+?`;\r\n    const result: Token[] = [];\r\n    let key = 0;\r\n    let i = 0;\r\n    let path = \"\";\r\n  \r\n    const tryConsume = (type: LexToken[\"type\"]): string | undefined => {\r\n      if (i < tokens.length && tokens[i].type === type) return tokens[i++].value;\r\n    };\r\n  \r\n    const mustConsume = (type: LexToken[\"type\"]): string => {\r\n      const value = tryConsume(type);\r\n      if (value !== undefined) return value;\r\n      const { type: nextType, index } = tokens[i];\r\n      throw new TypeError(`Unexpected ${nextType} at ${index}, expected ${type}`);\r\n    };\r\n  \r\n    const consumeText = (): string => {\r\n      let result = \"\";\r\n      let value: string | undefined;\r\n      // tslint:disable-next-line\r\n      while ((value = tryConsume(\"CHAR\") || tryConsume(\"ESCAPED_CHAR\"))) {\r\n        result += value;\r\n      }\r\n      return result;\r\n    };\r\n  \r\n    while (i < tokens.length) {\r\n      const char = tryConsume(\"CHAR\");\r\n      const name = tryConsume(\"NAME\");\r\n      const pattern = tryConsume(\"PATTERN\");\r\n  \r\n      if (name || pattern) {\r\n        let prefix = char || \"\";\r\n  \r\n        if (prefixes.indexOf(prefix) === -1) {\r\n          path += prefix;\r\n          prefix = \"\";\r\n        }\r\n  \r\n        if (path) {\r\n          result.push(path);\r\n          path = \"\";\r\n        }\r\n  \r\n        result.push({\r\n          name: name || key++,\r\n          prefix,\r\n          suffix: \"\",\r\n          pattern: pattern || defaultPattern,\r\n          modifier: tryConsume(\"MODIFIER\") || \"\"\r\n        });\r\n        continue;\r\n      }\r\n  \r\n      const value = char || tryConsume(\"ESCAPED_CHAR\");\r\n      if (value) {\r\n        path += value;\r\n        continue;\r\n      }\r\n  \r\n      if (path) {\r\n        result.push(path);\r\n        path = \"\";\r\n      }\r\n  \r\n      const open = tryConsume(\"OPEN\");\r\n      if (open) {\r\n        const prefix = consumeText();\r\n        const name = tryConsume(\"NAME\") || \"\";\r\n        const pattern = tryConsume(\"PATTERN\") || \"\";\r\n        const suffix = consumeText();\r\n  \r\n        mustConsume(\"CLOSE\");\r\n  \r\n        result.push({\r\n          name: name || (pattern ? key++ : \"\"),\r\n          pattern: name && !pattern ? defaultPattern : pattern,\r\n          prefix,\r\n          suffix,\r\n          modifier: tryConsume(\"MODIFIER\") || \"\"\r\n        });\r\n        continue;\r\n      }\r\n  \r\n      mustConsume(\"END\");\r\n    }\r\n  \r\n    return result;\r\n  }\r\n  \r\n  export interface TokensToFunctionOptions {\r\n    /**\r\n     * When `true` the regexp will be case sensitive. (default: `false`)\r\n     */\r\n    sensitive?: boolean;\r\n    /**\r\n     * Function for encoding input strings for output.\r\n     */\r\n    encode?: (value: string, token: Key) => string;\r\n    /**\r\n     * When `false` the function can produce an invalid (unmatched) path. (default: `true`)\r\n     */\r\n    validate?: boolean;\r\n  }\r\n  \r\n  /**\r\n   * Compile a string to a template function for the path.\r\n   */\r\n  export function compile<P extends object = object>(\r\n    str: string,\r\n    options?: ParseOptions & TokensToFunctionOptions\r\n  ) {\r\n    return tokensToFunction<P>(parse(str, options), options);\r\n  }\r\n  \r\n  export type PathFunction<P extends object = object> = (data?: P) => string;\r\n  \r\n  /**\r\n   * Expose a method for transforming tokens into the path function.\r\n   */\r\n  export function tokensToFunction<P extends object = object>(\r\n    tokens: Token[],\r\n    options: TokensToFunctionOptions = {}\r\n  ): PathFunction<P> {\r\n    const reFlags = flags(options);\r\n    const { encode = (x: string) => x, validate = true } = options;\r\n  \r\n    // Compile all the tokens into regexps.\r\n    const matches = tokens.map(token => {\r\n      if (typeof token === \"object\") {\r\n        return new RegExp(`^(?:${token.pattern})$`, reFlags);\r\n      }\r\n    });\r\n  \r\n    return (data: Record<string, any> | null | undefined) => {\r\n      let path = \"\";\r\n  \r\n      for (let i = 0; i < tokens.length; i++) {\r\n        const token = tokens[i];\r\n  \r\n        if (typeof token === \"string\") {\r\n          path += token;\r\n          continue;\r\n        }\r\n  \r\n        const value = data ? data[token.name] : undefined;\r\n        const optional = token.modifier === \"?\" || token.modifier === \"*\";\r\n        const repeat = token.modifier === \"*\" || token.modifier === \"+\";\r\n  \r\n        if (Array.isArray(value)) {\r\n          if (!repeat) {\r\n            throw new TypeError(\r\n              `Expected \"${token.name}\" to not repeat, but got an array`\r\n            );\r\n          }\r\n  \r\n          if (value.length === 0) {\r\n            if (optional) continue;\r\n  \r\n            throw new TypeError(`Expected \"${token.name}\" to not be empty`);\r\n          }\r\n  \r\n          for (let j = 0; j < value.length; j++) {\r\n            const segment = encode(value[j], token);\r\n  \r\n            if (validate && !(matches[i] as RegExp).test(segment)) {\r\n              throw new TypeError(\r\n                `Expected all \"${token.name}\" to match \"${token.pattern}\", but got \"${segment}\"`\r\n              );\r\n            }\r\n  \r\n            path += token.prefix + segment + token.suffix;\r\n          }\r\n  \r\n          continue;\r\n        }\r\n  \r\n        if (typeof value === \"string\" || typeof value === \"number\") {\r\n          const segment = encode(String(value), token);\r\n  \r\n          if (validate && !(matches[i] as RegExp).test(segment)) {\r\n            throw new TypeError(\r\n              `Expected \"${token.name}\" to match \"${token.pattern}\", but got \"${segment}\"`\r\n            );\r\n          }\r\n  \r\n          path += token.prefix + segment + token.suffix;\r\n          continue;\r\n        }\r\n  \r\n        if (optional) continue;\r\n  \r\n        const typeOfMessage = repeat ? \"an array\" : \"a string\";\r\n        throw new TypeError(`Expected \"${token.name}\" to be ${typeOfMessage}`);\r\n      }\r\n  \r\n      return path;\r\n    };\r\n  }\r\n  \r\n  export interface RegexpToFunctionOptions {\r\n    /**\r\n     * Function for decoding strings for params.\r\n     */\r\n    decode?: (value: string, token: Key) => string;\r\n  }\r\n  \r\n  /**\r\n   * A match result contains data about the path match.\r\n   */\r\n  export interface MatchResult<P extends object = object> {\r\n    path: string;\r\n    index: number;\r\n    params: P;\r\n  }\r\n  \r\n  /**\r\n   * A match is either `false` (no match) or a match result.\r\n   */\r\n  export type Match<P extends object = object> = false | MatchResult<P>;\r\n  \r\n  /**\r\n   * The match function takes a string and returns whether it matched the path.\r\n   */\r\n  export type MatchFunction<P extends object = object> = (\r\n    path: string\r\n  ) => Match<P>;\r\n  \r\n  /**\r\n   * Create path match function from `path-to-regexp` spec.\r\n   */\r\n  export function match<P extends object = object>(\r\n    str: Path,\r\n    options?: ParseOptions & TokensToRegexpOptions & RegexpToFunctionOptions\r\n  ) {\r\n    const keys: Key[] = [];\r\n    const re = pathToRegexp(str, keys, options);\r\n    return regexpToFunction<P>(re, keys, options);\r\n  }\r\n  \r\n  /**\r\n   * Create a path match function from `path-to-regexp` output.\r\n   */\r\n  export function regexpToFunction<P extends object = object>(\r\n    re: RegExp,\r\n    keys: Key[],\r\n    options: RegexpToFunctionOptions = {}\r\n  ): MatchFunction<P> {\r\n    const { decode = (x: string) => x } = options;\r\n  \r\n    return function(pathname: string) {\r\n      const m = re.exec(pathname);\r\n      if (!m) return false;\r\n  \r\n      const { 0: path, index } = m;\r\n      const params = Object.create(null);\r\n  \r\n      for (let i = 1; i < m.length; i++) {\r\n        // tslint:disable-next-line\r\n        if (m[i] === undefined) continue;\r\n  \r\n        const key = keys[i - 1];\r\n  \r\n        if (key.modifier === \"*\" || key.modifier === \"+\") {\r\n          params[key.name] = m[i].split(key.prefix + key.suffix).map(value => {\r\n            return decode(value, key);\r\n          });\r\n        } else {\r\n          params[key.name] = decode(m[i], key);\r\n        }\r\n      }\r\n  \r\n      return { path, index, params };\r\n    };\r\n  }\r\n  \r\n  /**\r\n   * Escape a regular expression string.\r\n   */\r\n  function escapeString(str: string) {\r\n    return str.replace(/([.+*?=^!:${}()[\\]|/\\\\])/g, \"\\\\$1\");\r\n  }\r\n  \r\n  /**\r\n   * Get the flags for a regexp from the options.\r\n   */\r\n  function flags(options?: { sensitive?: boolean }) {\r\n    return options && options.sensitive ? \"\" : \"i\";\r\n  }\r\n  \r\n  /**\r\n   * Metadata about a key.\r\n   */\r\n  export interface Key {\r\n    name: string | number;\r\n    prefix: string;\r\n    suffix: string;\r\n    pattern: string;\r\n    modifier: string;\r\n  }\r\n  \r\n  /**\r\n   * A token is a string (nothing special) or key metadata (capture group).\r\n   */\r\n  export type Token = string | Key;\r\n  \r\n  /**\r\n   * Pull out keys from a regexp.\r\n   */\r\n  function regexpToRegexp(path: RegExp, keys?: Key[]): RegExp {\r\n    if (!keys) return path;\r\n  \r\n    const groupsRegex = /\\((?:\\?<(.*?)>)?(?!\\?)/g;\r\n  \r\n    let index = 0;\r\n    let execResult = groupsRegex.exec(path.source);\r\n    while (execResult) {\r\n      keys.push({\r\n        // Use parenthesized substring match if available, index otherwise\r\n        name: execResult[1] || index++,\r\n        prefix: \"\",\r\n        suffix: \"\",\r\n        modifier: \"\",\r\n        pattern: \"\"\r\n      });\r\n      execResult = groupsRegex.exec(path.source);\r\n    }\r\n  \r\n    return path;\r\n  }\r\n  \r\n  /**\r\n   * Transform an array into a regexp.\r\n   */\r\n  function arrayToRegexp(\r\n    paths: Array<string | RegExp>,\r\n    keys?: Key[],\r\n    options?: TokensToRegexpOptions & ParseOptions\r\n  ): RegExp {\r\n    const parts = paths.map(path => pathToRegexp(path, keys, options).source);\r\n    return new RegExp(`(?:${parts.join(\"|\")})`, flags(options));\r\n  }\r\n  \r\n  /**\r\n   * Create a path regexp from string input.\r\n   */\r\n  function stringToRegexp(\r\n    path: string,\r\n    keys?: Key[],\r\n    options?: TokensToRegexpOptions & ParseOptions\r\n  ) {\r\n    return tokensToRegexp(parse(path, options), keys, options);\r\n  }\r\n  \r\n  export interface TokensToRegexpOptions {\r\n    /**\r\n     * When `true` the regexp will be case sensitive. (default: `false`)\r\n     */\r\n    sensitive?: boolean;\r\n    /**\r\n     * When `true` the regexp won't allow an optional trailing delimiter to match. (default: `false`)\r\n     */\r\n    strict?: boolean;\r\n    /**\r\n     * When `true` the regexp will match to the end of the string. (default: `true`)\r\n     */\r\n    end?: boolean;\r\n    /**\r\n     * When `true` the regexp will match from the beginning of the string. (default: `true`)\r\n     */\r\n    start?: boolean;\r\n    /**\r\n     * Sets the final character for non-ending optimistic matches. (default: `/`)\r\n     */\r\n    delimiter?: string;\r\n    /**\r\n     * List of characters that can also be \"end\" characters.\r\n     */\r\n    endsWith?: string;\r\n    /**\r\n     * Encode path tokens for use in the `RegExp`.\r\n     */\r\n    encode?: (value: string) => string;\r\n  }\r\n  \r\n  /**\r\n   * Expose a function for taking tokens and returning a RegExp.\r\n   */\r\n  export function tokensToRegexp(\r\n    tokens: Token[],\r\n    keys?: Key[],\r\n    options: TokensToRegexpOptions = {}\r\n  ) {\r\n    const {\r\n      strict = false,\r\n      start = true,\r\n      end = true,\r\n      encode = (x: string) => x\r\n    } = options;\r\n    const endsWith = `[${escapeString(options.endsWith || \"\")}]|$`;\r\n    const delimiter = `[${escapeString(options.delimiter || \"/#?\")}]`;\r\n    let route = start ? \"^\" : \"\";\r\n  \r\n    // Iterate over the tokens and create our regexp string.\r\n    for (const token of tokens) {\r\n      if (typeof token === \"string\") {\r\n        route += escapeString(encode(token));\r\n      } else {\r\n        const prefix = escapeString(encode(token.prefix));\r\n        const suffix = escapeString(encode(token.suffix));\r\n  \r\n        if (token.pattern) {\r\n          if (keys) keys.push(token);\r\n  \r\n          if (prefix || suffix) {\r\n            if (token.modifier === \"+\" || token.modifier === \"*\") {\r\n              const mod = token.modifier === \"*\" ? \"?\" : \"\";\r\n              route += `(?:${prefix}((?:${token.pattern})(?:${suffix}${prefix}(?:${token.pattern}))*)${suffix})${mod}`;\r\n            } else {\r\n              route += `(?:${prefix}(${token.pattern})${suffix})${token.modifier}`;\r\n            }\r\n          } else {\r\n            route += `(${token.pattern})${token.modifier}`;\r\n          }\r\n        } else {\r\n          route += `(?:${prefix}${suffix})${token.modifier}`;\r\n        }\r\n      }\r\n    }\r\n  \r\n    if (end) {\r\n      if (!strict) route += `${delimiter}?`;\r\n  \r\n      route += !options.endsWith ? \"$\" : `(?=${endsWith})`;\r\n    } else {\r\n      const endToken = tokens[tokens.length - 1];\r\n      const isEndDelimited =\r\n        typeof endToken === \"string\"\r\n          ? delimiter.indexOf(endToken[endToken.length - 1]) > -1\r\n          : // tslint:disable-next-line\r\n            endToken === undefined;\r\n  \r\n      if (!strict) {\r\n        route += `(?:${delimiter}(?=${endsWith}))?`;\r\n      }\r\n  \r\n      if (!isEndDelimited) {\r\n        route += `(?=${delimiter}|${endsWith})`;\r\n      }\r\n    }\r\n  \r\n    return new RegExp(route, flags(options));\r\n  }\r\n  \r\n  /**\r\n   * Supported `path-to-regexp` input types.\r\n   */\r\n  export type Path = string | RegExp | Array<string | RegExp>;\r\n  \r\n  /**\r\n   * Normalize the given path string, returning a regular expression.\r\n   *\r\n   * An empty array can be passed in for the keys, which will hold the\r\n   * placeholder key descriptions. For example, using `/user/:id`, `keys` will\r\n   * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.\r\n   */\r\n  export function pathToRegexp(\r\n    path: Path,\r\n    keys?: Key[],\r\n    options?: TokensToRegexpOptions & ParseOptions\r\n  ) {\r\n    if (path instanceof RegExp) return regexpToRegexp(path, keys);\r\n    if (Array.isArray(path)) return arrayToRegexp(path, keys, options);\r\n    return stringToRegexp(path, keys, options);\r\n  }"]}