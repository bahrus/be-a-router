{"version":3,"file":"url-utils.js","sourceRoot":"","sources":["../src/url-utils.ts"],"names":[],"mappings":"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","sourcesContent":["// Utility function to determine if a pathname is absolute or not.  For\r\n// URL values this mainly consists of a check for a leading slash.  For\r\n// patterns we do some additional checking for escaped or grouped slashes.\r\nexport function isAbsolutePathname(pathname: string, isPattern: boolean): boolean {\r\n  if (!pathname.length) {\r\n    return false;\r\n  }\r\n\r\n  if (pathname[0] === '/') {\r\n    return true;\r\n  }\r\n\r\n  if (!isPattern) {\r\n    return false;\r\n  }\r\n\r\n  if (pathname.length < 2) {\r\n    return false;\r\n  }\r\n\r\n  // Patterns treat escaped slashes and slashes within an explicit grouping as\r\n  // valid leading slashes.  For example, \"\\/foo\" or \"{/foo}\".  Patterns do\r\n  // not consider slashes within a custom regexp group as valid for the leading\r\n  // pathname slash for now.  To support that we would need to be able to\r\n  // detect things like \":name_123(/foo)\" as a valid leading group in a pattern,\r\n  // but that is considered too complex for now.\r\n  if ((pathname[0] == '\\\\' || pathname[0] == '{') && pathname[1] == '/') {\r\n    return true;\r\n  }\r\n\r\n  return false;\r\n}\r\n\r\nfunction isASCII(str: string, extended: boolean) {\r\n  return (extended ? /^[\\x00-\\xFF]*$/ : /^[\\x00-\\x7F]*$/).test(str);\r\n}\r\n\r\nfunction validatePatternEncoding(pattern: string, component: string) {\r\n  if (!pattern.length)\r\n    return pattern;\r\n  if (isASCII(pattern, false))\r\n    return pattern; // ASCII only\r\n\r\n  // TODO: Consider if we should canonicalize patterns instead.  See:\r\n  //       https://github.com/WICG/urlpattern/issues/33\r\n  throw new TypeError(`Illegal character in '${component}' pattern '${pattern}'. `\r\n    + \"Patterns must be URL encoded ASCII.\");\r\n}\r\n\r\nexport function canonicalizeHash(hash: string, isPattern: boolean) {\r\n  if (isPattern) {\r\n    return validatePatternEncoding(hash, \"hash\");\r\n  }\r\n  const url = new URL(\"https://example.com\");\r\n  url.hash = hash;\r\n  return url.hash ? url.hash.substring(1, url.hash.length) : '';\r\n}\r\n\r\nexport function canonicalizeSearch(search: string, isPattern: boolean) {\r\n  if (isPattern) {\r\n    return validatePatternEncoding(search, \"search\");\r\n  }\r\n  const url = new URL(\"https://example.com\");\r\n  url.search = search;\r\n  return url.search ? url.search.substring(1, url.search.length) : '';\r\n}\r\n\r\nexport function canonicalizeHostname(hostname: string, isPattern: boolean) {\r\n  if (isPattern) {\r\n    return validatePatternEncoding(hostname, \"hostname\");\r\n  }\r\n  const url = new URL(\"https://example.com\");\r\n  url.hostname = hostname;\r\n  return url.hostname;\r\n}\r\n\r\nexport function canonicalizePassword(password: string, isPattern: boolean) {\r\n  if (isPattern) {\r\n    return validatePatternEncoding(password, \"password\");\r\n  }\r\n  const url = new URL(\"https://example.com\");\r\n  url.password = password;\r\n  return url.password;\r\n}\r\n\r\nexport function canonicalizeUsername(username: string, isPattern: boolean) {\r\n  if (isPattern) {\r\n    return validatePatternEncoding(username, \"username\");\r\n  }\r\n  const url = new URL(\"https://example.com\");\r\n  url.username = username;\r\n  return url.username;\r\n}\r\n\r\nexport function canonicalizePathname(pathname: string, isPattern: boolean) {\r\n  if (isPattern) {\r\n    return validatePatternEncoding(pathname, \"pathname\");\r\n  }\r\n\r\n  const leadingSlash = pathname[0] == \"/\";\r\n  pathname = new URL(pathname, \"https://example.com\").pathname;\r\n  if (!leadingSlash) {\r\n    pathname = pathname.substring(1, pathname.length);\r\n  }\r\n\r\n  return pathname;\r\n}\r\n\r\nexport function canonicalizePort(port: string, isPattern: boolean): string {\r\n  if (isPattern) {\r\n    return validatePatternEncoding(port, \"port\");\r\n  }\r\n  // Since ports only consist of digits there should be no encoding needed.\r\n  // Therefore we directly use the UTF8 encoding version of CanonicalizePort().\r\n  if (/^[0-9]*$/.test(port) && parseInt(port) <= 65535) {\r\n    return port;\r\n  }\r\n  throw new TypeError(`Invalid port '${port}'.`);\r\n}\r\n\r\nexport function canonicalizeProtocol(protocol: string, isPattern: boolean) {\r\n  if (isPattern) {\r\n    return validatePatternEncoding(protocol, \"protocol\");\r\n  }\r\n\r\n  if (/^[-+.A-Za-z0-9]*$/.test(protocol))\r\n    return protocol.toLowerCase();\r\n  throw new TypeError(`Invalid protocol '${protocol}'.`);\r\n}\r\n\r\nexport function defaultPortForProtocol(protocol: string): string {\r\n  switch (protocol) {\r\n    case \"ws\":\r\n    case \"http\":\r\n      return '80';\r\n    case \"wws\":\r\n    case \"https\":\r\n      return '443';\r\n    case \"ftp\":\r\n      return '21';\r\n    default:\r\n      return '';\r\n  }\r\n}"]}